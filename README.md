# Frost
Frost lets you manage your Snowflake node IDs.

## What's Snowflake?
Snowflake IDs are special 8-byte IDs generated by Twitter's 
[Snowflake](https://developer.twitter.com/en/docs/basics/twitter-ids) 
[algorithm](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake.html).

Each Snowflake ID is a 63 bit int.
- 41 bits for a timestamp (milliseconds since a custom epoch)
- 10 bits for a **node ID** (ranging from 0 to 1023)
- 12 bits for a sequence number (ranging from 0 to 4095)

## Why Frost?
If you're planning on horizontally scaling (i.e., replicating) your app, 
you'll need a way of doling out **node IDs**.

Thanks to tools like Docker, we are entering the era of containers, in which applications are expected to be ephemeral.
Your container (or "Pod," if you use Kubernetes) can go down at any moment.
If that happens, your app has no way of relinquishing its node ID.

In short, we need a coordinated solution for managing node IDs.

## What does Frost do?
Frost maintains two maps of app IDs.
An app ID is a string and can represent anything (an int, a UUID, a hash, etc).

The *Node Map* maps app IDs to node IDs (an int ranging from 0 to 1023).

The *Heartbeat Map* maps app IDs to the latest heartbeat time of that app.

Apps must send heartbeats to Frost routinely, otherwise its entries are removed from both maps.

Every N seconds, Frost checks for heartbeat times older than M seconds and removes accordingly.
